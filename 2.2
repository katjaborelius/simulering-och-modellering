#!/bin/python3
# Template for traffic simulation
# BH, MP 2021-11-15, latest version 2024-11-08.
"""
This template is used as backbone for the traffic simulations.
Its structure resembles the one of the pendulum project, that is you have:
(a) a class containing the state of the system and it's parameters
(b) a class storing the observables that you want then to plot
(c) a class that propagates the state in time (which in this case is discrete),
and
(d) a class that encapsulates the aforementioned ones and performs the actual
simulation
You are asked to implement the propagation rule(s) corresponding to the traffic
model(s) of the project.
"""
import math
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy.random as rng
import numpy as np
import matplotlib
class Cars:
    """ Class for the state of a number of cars """
    def __init__(self, numCars=5, roadLength=50, v0=1):
        self.numCars = numCars
        self.roadLength = roadLength
        self.t = 0
        self.x = []
        self.v = []
        self.c = []
        for i in range(numCars):
            # TODO: Set the initial position for each car.
            # Note that the ordering of the cars on the road needs to match
            # the order in which you compute the distances between cars
            self.x.append(i) # the position of the cars on the road
            self.v.append(v0) # the speed of the cars
            self.c.append(i) # the color of the cars (for drawing)
            # NOTE: you can, but don't have to use this function for computing distances

    def distance(self, i):
        # Find the position of the car in front
        front = (i + 1) % self.numCars
        # Compute the periodic distance
        return (self.x[front] - self.x[i]) % self.roadLength

class Observables:
    """ Class for storing observables """
    def __init__(self):
        self.time = [] # list to store time
        self.flowrate = [] # list to store the flow rate
class BasePropagator:
    def __init__(self):
        return

    def propagate(self, cars, obs):
        """ Perform a single integration step """
        fr = self.timestep(cars, obs)
        # Append observables to their lists
        obs.time.append(cars.t)
        obs.flowrate.append(fr)

    def timestep(self, cars, obs):
        # Step 1: Acceleration
        for i in range(cars.numCars):
            if cars.v[i] < self.vmax:
                cars.v[i] += 1

        # Step 2: Avoid collisions
        for i in range(cars.numCars):
            gap = cars.distance(i)
            if cars.v[i] > gap:
                cars.v[i] = gap

        # Step 3: Random deceleration
        for i in range(cars.numCars):
            if rng.random() < self.p and cars.v[i] > 0:
                cars.v[i] -= 1

        # Step 4: Move cars
        for i in range(cars.numCars):
            cars.x[i] = (cars.x[i] + cars.v[i]) % cars.roadLength

        # Step 5: Compute flow rate (cars crossing a specific point, e.g., x=0)
        flow_rate = sum(1 for i in range(cars.numCars) if (cars.x[i] - cars.v[i]) % cars.roadLength == 0)

        # Increment time
        cars.t += 1
        return flow_rate


class ConstantPropagator(BasePropagator) :
    """
    Cars do not interact: each position is just
    updated using the corresponding velocity
    """
    def timestep(self, cars, obs):
        for i in range(cars.numCars):
            cars.x[i] += cars.v[i]
        cars.t += 1
        return 0
        # TODO
        # HERE YOU SHOULD IMPLEMENT THE DIFFERENT CAR BEHAVIOR RULES
        # Define you own class which inherits from BasePropagator (e.g. MyPropagator(BasePropagator))
        # and implement timestep according to the rule described in the project

class MyPropagator(BasePropagator):
    def __init__(self, vmax, p):
        super().__init__()
        self.vmax = vmax
        self.p = p

    def timestep(self, cars, obs):
        # Step 1: Acceleration
        for i in range(cars.numCars):
            if cars.v[i] < self.vmax:
                cars.v[i] += 1

        # Step 2: Prevent collisions
        for i in range(cars.numCars):
            gap = cars.distance(i)  # Compute distance to the next car
            if cars.v[i] >= gap:
                cars.v[i] = gap - 1

        # Step 3: Random deceleration
        for i in range(cars.numCars):
            if rng.random() < self.p and cars.v[i] > 0:
                cars.v[i] -= 1

        # Step 4: Update positions
        for i in range(cars.numCars):
            cars.x[i] = (cars.x[i] + cars.v[i]) % cars.roadLength

        # Calculate the flow rate
        flow_rate = sum(cars.v) / cars.roadLength

        # Increment time
        cars.t += 1
        return flow_rate



    def draw_cars(cars, cars_drawing):
        """ Used later on to generate the animation """
        theta = []
        r = []
        for position in cars.x:
            # Convert to radians for plotting only (do not use radians for the simulation!)
            theta.append(position * 2 * math.pi / cars.roadLength)
            r.append(1)
        return cars_drawing.scatter(theta, r, c=cars.c, cmap='hsv')
    def animate(framenr, cars, obs, propagator, road_drawing, stepsperframe):
        """ Animation function which integrates a few steps and return a drawing """
        for it in range(stepsperframe):
            propagator.propagate(cars, obs)
        return draw_cars(cars, road_drawing),
class Simulation:
    def reset(self, cars=Cars()) :
        self.cars = cars
        self.obs = Observables()

    def __init__(self, cars=Cars()) :
        self.reset(cars)

    def plot_observables(self, title="simulation"):
        plt.clf()
        plt.title(title)
        plt.plot(self.obs.time, self.obs.flowrate)
        plt.xlabel('time')
        plt.ylabel('flow rate')
        plt.savefig(title + ".pdf")
        plt.show()
        # Run without displaying any animation (fast)
    def run(self,propagator, numsteps=200,  title="simulation"):
        for it in range(numsteps):
            propagator.propagate(self.cars, self.obs)
            self.plot_observables(title)
            # Run while displaying the animation of bunch of cars going in circe (slow-ish)

    def run_animate(self, propagator,numsteps=200, stepsperframe=1, title="simulation"):
        numframes = int(numsteps / stepsperframe)
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='polar')
        ax.axis('off')
        # Call the animator, blit=False means re-draw everything
        anim = animation.FuncAnimation(plt.gcf(), animate, # init_func=init,
        fargs=[self.cars,self.obs,propagator,ax,stepsperframe],
        frames=numframes, interval=50, blit=True,
        repeat=False)
        plt.show()
        # If you experience problems visualizing the animation and/or
        # the following figures comment out the next line
        # plt.waitforbuttonpress(30)
        self.plot_observables(title)
        # It's good practice to encapsulate the script execution in
        # a main() function (e.g. for profiling reasons)


def main() :
    # Here you can define one or more instances of cars, with possibly different parameters,
    # and pass them to the simulator
    # Be sure you are passing the correct initial conditions!
    #cars = Cars(numCars = 5, roadLength=50)
    # Create the simulation object for your cars instance:
    #simulation = Simulation(cars)
    # simulation.run_animate(propagator=ConstantPropagator())
    #simulation.run_animate(propagator=MyPropagator(vmax=2, p=0.2))
    # Calling 'main()' if the script is executed.
    # If the script is instead just imported, main is not called (this can be useful if you want to
    # write another script importing and utilizing the functions and classes defined in this one)
    roadLength = 100
    densities = np.linspace(0.1, 1.0, 10)  # Densities from 0.1 to 1.0
    flow_rates = []

    for density in densities:
        numCars = int(density * roadLength)
        cars = Cars(numCars=numCars, roadLength=roadLength)
        simulation = Simulation(cars)
        propagator = MyPropagator(vmax=2, p=0.5)
        simulation.run(propagator, numsteps=500)  # Allow system to equilibrate
        avg_flow_rate = np.mean(simulation.obs.flowrate[-100:])  # Average flow rate
        flow_rates.append(avg_flow_rate)

    # Plot the fundamental diagram
    plt.plot(densities, flow_rates, marker='o')
    plt.xlabel('Density')
    plt.ylabel('Flow Rate')
    plt.title('Fundamental Diagram')
    plt.grid()
    plt.show()


if __name__ == "__main__" :
    main()

